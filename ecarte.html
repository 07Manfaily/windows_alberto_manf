const _ciblage = async () => {
  try {
    // V√©rifier que selectedKeysCritere existe et n'est pas vide
    if (!selectedKeysCritere || selectedKeysCritere.length === 0) {
      toast.error("Veuillez s√©lectionner au moins un crit√®re de ciblage", {
        position: "top-right",
        autoClose: 3000,
        hideProgressBar: false,
        closeOnClick: true,
        pauseOnHover: true,
        draggable: true,
        theme: "dark",
      });
      return; // Arr√™ter l'ex√©cution si aucun crit√®re s√©lectionn√©
    }

    console.log("Crit√®res s√©lectionn√©s √† envoyer:", selectedKeysCritere);

    const response = await api.post(
      `/repartir/participant/${code}`,
      {
        participants: defaultParticipant,
        force: force ? 1 : null,
        create_session: create ? 1 : null,
        targeting_constraints: selectedKeysCritere, // Votre tableau de cl√©s
      },
      {
        headers: {
          "Content-Type": "application/json",
        },
      }
    );

    console.log("response", response);

    // V√©rifier le statut de la r√©ponse
    if (response.status === 200 || response.status === 201) {
      // V√©rifier si la r√©ponse indique un succ√®s
      if (response.data && response.data.success !== false) {
        toast.success("Ciblage effectu√© üëç", {
          position: "top-right",
          autoClose: 3000,
          hideProgressBar: false,
          closeOnClick: true,
          pauseOnHover: true,
          draggable: true,
          progress: undefined,
          theme: "dark",
        });
        
        // Actions apr√®s succ√®s (fermer modal, rafra√Æchir donn√©es, etc.)
        setOpen(true); // ou handleClose() selon votre logique
        
        // Optionnel : rafra√Æchir les donn√©es ou rediriger
        // await fetchUpdatedData();
        
      } else {
        // API a r√©pondu 200 mais avec une erreur m√©tier
        const errorMessage = response.data?.message || "Erreur lors du ciblage";
        toast.error(errorMessage, {
          position: "top-right",
          autoClose: 4000,
          theme: "dark",
        });
      }
    } else {
      // Statut HTTP non attendu
      toast.error(`Erreur HTTP: ${response.status}`, {
        position: "top-right",
        autoClose: 4000,
        theme: "dark",
      });
    }

  } catch (error) {
    console.error("Erreur lors du ciblage:", error);
    
    // Gestion d√©taill√©e des erreurs
    let errorMessage = "Erreur lors du ciblage";
    
    if (error.response) {
      // L'API a r√©pondu avec un statut d'erreur
      const status = error.response.status;
      const data = error.response.data;
      
      switch (status) {
        case 400:
          errorMessage = data?.message || "Donn√©es invalides";
          break;
        case 401:
          errorMessage = "Non autoris√© - Veuillez vous reconnecter";
          break;
        case 403:
          errorMessage = "Acc√®s interdit";
          break;
        case 404:
          errorMessage = "Ressource non trouv√©e";
          break;
        case 422:
          errorMessage = data?.message || "Erreur de validation";
          break;
        case 500:
          errorMessage = "Erreur serveur - Veuillez r√©essayer";
          break;
        default:
          errorMessage = `Erreur ${status}: ${data?.message || "Erreur inconnue"}`;
      }
    } else if (error.request) {
      // Pas de r√©ponse du serveur
      errorMessage = "Pas de r√©ponse du serveur - V√©rifiez votre connexion";
    } else {
      // Erreur dans la configuration de la requ√™te
      errorMessage = "Erreur de configuration de la requ√™te";
    }
    
    toast.error(errorMessage, {
      position: "top-right",
      autoClose: 5000,
      hideProgressBar: false,
      closeOnClick: true,
      pauseOnHover: true,
      draggable: true,
      theme: "dark",
    });
  }
};

// Fonction pour pr√©parer selectedKeysCritere avant l'envoi
const prepareSelectedCriteria = () => {
  const selectedKeys = Object.entries(selectedCriteria)
    .filter(([key, isSelected]) => isSelected)
    .map(([key]) => key);
    
  console.log("Crit√®res pr√©par√©s:", selectedKeys);
  return selectedKeys;
};

// Fonction compl√®te qui pr√©pare et envoie
const handleCiblageSubmit = async () => {
  // Pr√©parer les crit√®res s√©lectionn√©s
  const selectedKeysCritere = prepareSelectedCriteria();
  
  // Validation
  if (selectedKeysCritere.length === 0) {
    toast.warning("Veuillez s√©lectionner au moins un crit√®re", {
      position: "top-right",
      autoClose: 3000,
      theme: "dark",
    });
    return;
  }
  
  // Confirmer avant envoi (optionnel)
  const confirmSend = window.confirm(
    `Voulez-vous appliquer le ciblage avec ${selectedKeysCritere.length} crit√®re(s) s√©lectionn√©(s) ?`
  );
  
  if (confirmSend) {
    await _ciblage(selectedKeysCritere);
  }
};

// Bouton d'envoi am√©lior√©
const SubmitButton = () => {
  const selectedCount = Object.values(selectedCriteria).filter(Boolean).length;
  
  return (
    <button
      onClick={handleCiblageSubmit}
      disabled={selectedCount === 0}
      style={{
        padding: '12px 24px',
        backgroundColor: selectedCount > 0 ? '#1732bb' : '#ccc',
        color: 'white',
        border: 'none',
        borderRadius: '6px',
        fontSize: '16px',
        fontWeight: '600',
        cursor: selectedCount > 0 ? 'pointer' : 'not-allowed',
        marginTop: '20px',
        transition: 'background-color 0.2s ease'
      }}
    >
      {selectedCount > 0 
        ? `Appliquer le ciblage (${selectedCount} crit√®re${selectedCount > 1 ? 's' : ''})` 
        : 'S√©lectionnez des crit√®res'
      }
    </button>
  );
};
